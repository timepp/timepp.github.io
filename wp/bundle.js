/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/css-modules-typescript-loader/index.js!./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/sass-loader/dist/cjs.js!./src/app.scss":
/*!*************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-modules-typescript-loader/index.js!./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/sass-loader/dist/cjs.js!./src/app.scss ***!
  \*************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".xXYUSSUvW9so5mbZ_bUO {\\n  background-color: #F0F0F0;\\n  margin-bottom: 0.5em;\\n}\\n\\n.xXYUSSUvW9so5mbZ_bUO button {\\n  margin: 0.5em;\\n  height: 2em;\\n}\\n\\n._63YrTXMJjw9IWGdTnbQ {\\n  background-color: #F0F0F0;\\n  margin-bottom: 0.5em;\\n}\", \"\"]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"toolbar\": \"xXYUSSUvW9so5mbZ_bUO\",\n\t\"another\": \"_63YrTXMJjw9IWGdTnbQ\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://witness-puzzle/./src/app.scss?./node_modules/css-modules-typescript-loader/index.js!./node_modules/css-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B2%5D!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./src/app.scss":
/*!**********************!*\
  !*** ./src/app.scss ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_modules_typescript_loader_index_js_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_sass_loader_dist_cjs_js_app_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-modules-typescript-loader/index.js!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!../node_modules/sass-loader/dist/cjs.js!./app.scss */ \"./node_modules/css-modules-typescript-loader/index.js!./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/sass-loader/dist/cjs.js!./src/app.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_modules_typescript_loader_index_js_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_sass_loader_dist_cjs_js_app_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_modules_typescript_loader_index_js_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_sass_loader_dist_cjs_js_app_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_modules_typescript_loader_index_js_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_sass_loader_dist_cjs_js_app_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_modules_typescript_loader_index_js_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_sass_loader_dist_cjs_js_app_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://witness-puzzle/./src/app.scss?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://witness-puzzle/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ \"./src/settings.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var _app_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app.scss */ \"./src/app.scss\");\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log */ \"./src/log.ts\");\n\n\n\n\n\nlet puzzle;\nlet loadIndex = -1;\nlet savedPuzzles = [];\nwindow.onload = init;\nfunction init() {\n    _log__WEBPACK_IMPORTED_MODULE_4__.EnableLogs(_log__WEBPACK_IMPORTED_MODULE_4__.Tags.PathTracking);\n    if (window.localStorage.savedPuzzles) {\n        savedPuzzles = JSON.parse(window.localStorage.savedPuzzles);\n    }\n    const page = document.createElement('div');\n    const toolbar = document.createElement('div');\n    const board = document.createElement('div');\n    toolbar.className = _app_scss__WEBPACK_IMPORTED_MODULE_3__[\"default\"].toolbar;\n    page.appendChild(toolbar);\n    page.appendChild(board);\n    document.body.appendChild(page);\n    _main__WEBPACK_IMPORTED_MODULE_0__.setContainer(board);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'New', newPuzzle);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Solve', () => _main__WEBPACK_IMPORTED_MODULE_0__.showSolution());\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Save', save);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Save to clipboard', saveToClipboard);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Load', loadNext);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Load from clipboard', loadFromClipboard);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Remove', removeSaved);\n    _ui__WEBPACK_IMPORTED_MODULE_2__.appendButton(toolbar, 'Settings', () => {\n        _settings__WEBPACK_IMPORTED_MODULE_1__.showSettingsPage(() => {\n            newPuzzle();\n        });\n    });\n    newPuzzle();\n}\nfunction newPuzzle() {\n    puzzle = _main__WEBPACK_IMPORTED_MODULE_0__.generatePuzzle(_settings__WEBPACK_IMPORTED_MODULE_1__.getPuzzleConfig());\n    console.log(_settings__WEBPACK_IMPORTED_MODULE_1__.PuzzleToString(puzzle));\n    console.log(JSON.stringify(puzzle));\n    _main__WEBPACK_IMPORTED_MODULE_0__.showPuzzle(puzzle);\n}\nfunction save() {\n    const sp = JSON.stringify(puzzle);\n    const index = savedPuzzles.indexOf(sp);\n    if (index === -1) {\n        savedPuzzles.push(sp);\n        window.localStorage.savedPuzzles = JSON.stringify(savedPuzzles);\n        loadIndex = savedPuzzles.length - 1;\n    }\n    else {\n        loadIndex = index;\n    }\n    updateInfo();\n}\nfunction saveToClipboard() {\n    const sp = JSON.stringify(puzzle, null, 4);\n    const el = document.createElement('textarea');\n    el.value = sp;\n    document.body.appendChild(el);\n    el.select();\n    document.execCommand('copy');\n    document.body.removeChild(el);\n}\nasync function loadFromClipboard() {\n    const sp = await navigator.clipboard.readText();\n    puzzle = JSON.parse(sp);\n    _main__WEBPACK_IMPORTED_MODULE_0__.showPuzzle(puzzle);\n}\nfunction loadNext() {\n    if (savedPuzzles.length > 0) {\n        loadIndex = (loadIndex + 1) % savedPuzzles.length;\n        const puzzleStr = savedPuzzles[loadIndex];\n        puzzle = JSON.parse(puzzleStr);\n        _main__WEBPACK_IMPORTED_MODULE_0__.showPuzzle(puzzle);\n        updateInfo();\n    }\n}\nfunction removeSaved() {\n    if (loadIndex >= 0) {\n        savedPuzzles.splice(loadIndex, 1);\n        loadIndex = -1;\n        window.localStorage.savedPuzzles = JSON.stringify(savedPuzzles);\n        updateInfo();\n    }\n}\nfunction updateInfo() {\n    const s = loadIndex === -1 ? '-' : loadIndex + 1;\n    const info = document.getElementById('info');\n    if (info) {\n        info.textContent = `${s} / ${savedPuzzles.length}`;\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/app.ts?");

/***/ }),

/***/ "./src/canvasdrawer.ts":
/*!*****************************!*\
  !*** ./src/canvasdrawer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasDrawer\": () => (/* binding */ CanvasDrawer)\n/* harmony export */ });\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape */ \"./src/shape.ts\");\n/* harmony import */ var _geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geo */ \"./src/geo.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log */ \"./src/log.ts\");\n\n\n\n\n\nfunction ensure(p) {\n    if (p === null)\n        throw new Error('error');\n    return p;\n}\nclass CanvasDrawer {\n    elem;\n    ctx;\n    backgroundColor;\n    cc;\n    rc;\n    lc;\n    colorTheme;\n    saw = true;\n    puzzle = new _main__WEBPACK_IMPORTED_MODULE_0__.Puzzle();\n    path = [];\n    walking = false;\n    completing = false;\n    checkResult = [];\n    cw = 0;\n    ch = 0;\n    rw = 0;\n    tx = 0;\n    ty = 0;\n    endPoint = [0, 0];\n    activeStartPoint = [0, 0];\n    coStartPoints = [];\n    coPath = [];\n    constructor(e, bc, cc, rc, lc, colorTheme) {\n        this.elem = e;\n        this.ctx = ensure(e.getContext('2d'));\n        this.backgroundColor = bc;\n        this.cc = cc;\n        this.rc = rc;\n        this.lc = lc;\n        this.colorTheme = colorTheme;\n        this.registerListeners();\n    }\n    translate(p) {\n        return [p[0] * this.cw, p[1] * this.ch];\n    }\n    screenToClient(x, y) {\n        const r = [\n            x - this.elem.getBoundingClientRect().left - this.tx,\n            this.elem.clientWidth - (y - this.elem.getBoundingClientRect().top + this.ty)\n        ];\n        return r;\n    }\n    setPuzzle(puzzle) {\n        const e = this.elem;\n        this.puzzle = puzzle;\n        this.path = [];\n        this.walking = false;\n        this.completing = false;\n        this.cw = Math.floor(e.clientWidth / (puzzle.m + 1));\n        // hacky: we need to make sure cw and ch are even, \n        // otherwise some of the calculations will be wrong since these are using /2 and *2\n        if (this.cw % 2 === 1)\n            this.cw -= 1;\n        this.ch = this.cw;\n        this.rw = Math.min(Math.floor(this.cw / 4), 50);\n        this.tx = Math.floor((e.clientWidth - this.cw * puzzle.m) / 2);\n        this.ty = this.tx;\n        this.endPoint = this.getEndPoint();\n        this.ctx.resetTransform();\n        this.ctx.fillStyle = this.backgroundColor;\n        this.ctx.fillRect(0, 0, e.clientWidth, e.clientHeight);\n        this.ctx.translate(this.tx, e.clientWidth - this.ty);\n        this.ctx.scale(1, -1);\n        this.draw(this.puzzle);\n    }\n    /**\n       *\n       * @param {Puzzle} puzzle\n       */\n    draw(puzzle) {\n        this.drawBoard();\n        this.drawFrame();\n        this.drawCellObjects(puzzle.cellObjects, puzzle.m, puzzle.n);\n    }\n    drawSolution() {\n        const path = this.puzzle.path.map(v => [v[0] * this.cw, v[1] * this.ch]);\n        path.push(this.endPoint);\n        this.drawFrame();\n        this.drawPath(path);\n    }\n    /**\n       * frame := roads + gaps + start point(s) + end point(s) + hexagons\n       */\n    drawFrame() {\n        const puzzle = this.puzzle;\n        this.drawRoad();\n        this.drawBorderObjects(false, o => o.type === 'gap');\n        puzzle.startPoints.forEach(p => {\n            this.drawStartPoint(this.translate([p[0], p[1]]), this.rc);\n            for (let i = 2; i < p.length; i += 4) {\n                this.drawStartPoint(this.translate([p[i], p[i + 1]]), this.rc);\n            }\n        });\n        // TODO: draw costarts\n        this.drawEndPoint();\n        this.drawBorderObjects(false, o => o.type === 'hexagon');\n    }\n    registerListeners() {\n        const cd = this;\n        this.elem.addEventListener('click', function (event) {\n            cd.onClick(event);\n        });\n        this.elem.addEventListener('mousemove', function (event) {\n            cd.onSolveMoving(event.pageX, event.pageY);\n        });\n        this.elem.addEventListener('touchstart', function (event) {\n            cd.onTouchStart(event);\n        });\n        this.elem.addEventListener('touchmove', function (event) {\n            cd.onTouchMove(event);\n        });\n        this.elem.addEventListener('touchend', function (event) {\n            cd.onTouchEnd(event);\n        });\n    }\n    onTouchStart(event) {\n        console.log(event);\n        event.preventDefault();\n        const t = event.changedTouches[0];\n        const [x, y] = this.screenToClient(t.clientX, t.clientY);\n        // check start points\n        for (const sp of this.puzzle.startPoints) {\n            const p = this.translate([sp[0], sp[1]]);\n            if (this.insideStartPoint(x, y, p)) {\n                console.log('walking');\n                if (this.walking) {\n                    this.walking = false;\n                    this.completing = false;\n                    this.path = [];\n                    this.draw(this.puzzle);\n                    return;\n                }\n                this.walking = true;\n                this.path = [p, [...p]];\n                this.draw(this.puzzle);\n                this.drawAllPaths();\n            }\n        }\n    }\n    onTouchMove(event) {\n        event.preventDefault();\n        const t = event.changedTouches[0];\n        this.onSolveMoving(t.clientX, t.clientY);\n    }\n    checkCompletion() {\n        if (this.completing) {\n            // check solution\n            this.walking = false;\n            const fullPath = this.getAllPaths().map(p => this.getFullPath(p));\n            this.checkResult = (0,_main__WEBPACK_IMPORTED_MODULE_0__.checkPath)(this.puzzle, fullPath, true);\n            if (this.checkResult.length === 0) {\n                this.drawAllPaths('rgb(0, 255, 0)');\n                this.playCheers();\n            }\n            else {\n                this.drawAllPaths('rgb(255, 0, 0)');\n                this.drawCellObjects(this.puzzle.cellObjects, this.puzzle.m, this.puzzle.n, true);\n                this.drawBorderObjects(true);\n                this.playWrong();\n            }\n            console.log('full path: ', JSON.stringify(fullPath));\n            this.completing = false;\n        }\n    }\n    playCheers() {\n        const wav = _util__WEBPACK_IMPORTED_MODULE_3__.randomPickOne(['success1.wav', 'success2.wav', 'success3.wav']);\n        //new Audio('sound/' + wav).play()\n    }\n    playWrong() {\n        const wav = _util__WEBPACK_IMPORTED_MODULE_3__.randomPickOne(['failed1.wav', 'failed2.wav']);\n        //new Audio('sound/' + wav).play()\n    }\n    onTouchEnd(event) {\n        event.preventDefault();\n        this.checkCompletion();\n    }\n    onClick(event) {\n        console.log(event);\n        this.checkCompletion();\n        if (this.walking) {\n            this.setPuzzle(this.puzzle);\n            return;\n        }\n        const [x, y] = this.screenToClient(event.pageX, event.pageY);\n        // check start points\n        for (const sp of this.puzzle.startPoints) {\n            const p = this.translate([sp[0], sp[1]]);\n            if (this.insideStartPoint(x, y, p)) {\n                console.log('walking');\n                this.activeStartPoint = sp;\n                this.coStartPoints = [];\n                for (let i = 2; i < sp.length; i += 4) {\n                    this.coStartPoints.push({ startPoint: [sp[i], sp[i + 1]], dir: [sp[i + 2], sp[i + 3]] });\n                }\n                this.walking = true;\n                this.path = [p, [...p]];\n                this.logPath('start:');\n                this.draw(this.puzzle);\n                this.drawAllPaths();\n                return;\n            }\n        }\n    }\n    logPath(c = '') {\n        (0,_log__WEBPACK_IMPORTED_MODULE_4__.Log)(_log__WEBPACK_IMPORTED_MODULE_4__.Tags.PathTracking, c + JSON.stringify(this.path));\n    }\n    pointEqual(p1, p2) {\n        return p1[0] === p2[0] && p1[1] === p2[1];\n    }\n    tryExtendPathTo(x, y) {\n        // console.log('try', x, y)\n        // [x, y] should lay in grid\n        if (x % this.cw !== 0 && y % this.ch !== 0)\n            throw new Error('x, y should lay in grid');\n        const [x0, y0] = this.path.at(-1);\n        if (x0 === x && y0 === y)\n            return true;\n        const ep = this.matchEndPoint([x0, y0]);\n        if (ep) {\n            // exit point back to the corresponding end point first\n            this.path.push(this.translate(ep));\n            _util__WEBPACK_IMPORTED_MODULE_3__.simplifyPathInPlace(this.path);\n            return false;\n        }\n        const [xc, yc] = x0 % this.cw === 0 ? [x0, y] : [x, y0];\n        console.log(`routing from ${x0}, ${y0} to ${x}, ${y}; middle: ${xc}, ${yc}`);\n        const [x1, y1] = this.findMaxAllowedEndPoint(x0, y0, xc, yc);\n        this.path.push([x1, y1]);\n        _util__WEBPACK_IMPORTED_MODULE_3__.simplifyPathInPlace(this.path);\n        this.logPath(`max allowed end point, ${x0}, ${y0}, ${xc}, ${yc}, ${x1}, ${y1}`);\n        if (x1 === xc && y1 === yc && xc % this.cw === 0 && yc % this.ch === 0) {\n            const [x2, y2] = this.findMaxAllowedEndPoint(xc, yc, x, y);\n            this.path.push([x2, y2]);\n            this.logPath(`max allowed end point, ${x0}, ${y0}, ${x}, ${y}, ${x2}, ${y2}`);\n        }\n        _util__WEBPACK_IMPORTED_MODULE_3__.simplifyPathInPlace(this.path);\n        return this.pointEqual(this.path.at(-1), [x, y]);\n    }\n    onSolveMoving(pageX, pageY) {\n        if (!this.walking)\n            return;\n        const [x, y] = this.screenToClient(pageX, pageY);\n        // find the point in the grid(xg, yg) that is nearest to [x,y]\n        const r = this.findNearestPointInMap(x, y);\n        if (r.exit && this.pointEqual(r.exit, this.path.at(-1))) {\n            // we are still in the exit point range\n            return;\n        }\n        const extended = this.tryExtendPathTo(r.nearest[0], r.nearest[1]);\n        if (extended && r.exit) {\n            this.path.push(r.exit);\n        }\n        _util__WEBPACK_IMPORTED_MODULE_3__.simplifyPathInPlace(this.path);\n        // console.log('nearest point: ', JSON.stringify(r))\n        this.completing = this.matchEndPoint(this.path[this.path.length - 1]) !== undefined;\n        this.drawFrame();\n        const style = this.completing ? 'rgb(255,255,255)' : undefined;\n        this.drawAllPaths(style);\n    }\n    drawStartPoint(p, style) {\n        this.ctx.fillStyle = style;\n        this.ctx.beginPath();\n        this.ctx.arc(p[0], p[1], this.rw, 0, 2 * Math.PI);\n        this.ctx.fill();\n    }\n    drawBorderObjects(showCheckResult, filterFunc) {\n        for (let i = 0; i <= this.puzzle.m * 2; i++) {\n            for (let j = 0; j <= this.puzzle.n * 2; j++) {\n                this.drawBorderObject(this.puzzle.borderObjects[i][j], i, j, showCheckResult, filterFunc);\n            }\n        }\n    }\n    drawBorderObject(obj, i, j, showCheckResult, filterFunc) {\n        if (!obj)\n            return;\n        if (filterFunc && !filterFunc(obj))\n            return;\n        const color = showCheckResult && !this.isCorrect(i, j) ? 'rgb(255,0,0)' : this.colorTheme[obj.color];\n        if (obj.type === 'hexagon') {\n            this.drawHexagon(i * this.cw / 2, j * this.ch / 2, this.rw / 3, color);\n        }\n        else if (obj.type === 'gap') {\n            const gapObject = obj;\n            const [cw, ch, rw] = [this.cw, this.ch, this.rw];\n            const x1 = (i % 2 === 0) ? i / 2 : (i - 1) / 2;\n            const y1 = (j % 2 === 0) ? j / 2 : (j - 1) / 2;\n            const x2 = (i % 2 === 0) ? i / 2 : (i + 1) / 2;\n            const y2 = (j % 2 === 0) ? j / 2 : (j + 1) / 2;\n            const r1 = (1 - gapObject.length) / 2;\n            const r2 = r1 + gapObject.length;\n            const lw = cw - rw;\n            const lh = ch - rw;\n            const X1 = x1 * cw + rw / 2 * (x2 - x1) + (x2 - x1) * lw * r1;\n            const Y1 = y1 * ch + rw / 2 * (y2 - y1) + (y2 - y1) * lh * r1;\n            const X2 = x1 * cw + rw / 2 * (x2 - x1) + (x2 - x1) * lw * r2;\n            const Y2 = y1 * ch + rw / 2 * (y2 - y1) + (y2 - y1) * lh * r2;\n            this.drawGap(X1, Y1, X2, Y2);\n        }\n    }\n    drawCellObjects(arr, m, n, showCheckResult = false) {\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                this.drawCellObject(arr[i][j], i, j, showCheckResult);\n            }\n        }\n    }\n    isCorrect(i, j) {\n        for (const [x, y] of this.checkResult) {\n            if (x === i && y === j)\n                return false;\n        }\n        return true;\n    }\n    drawCellObject(obj, i, j, showCheckResult) {\n        if (!obj)\n            return;\n        const color = showCheckResult && !this.isCorrect(i * 2, j * 2) ? 'rgb(255,0,0)' : this.colorTheme[obj.color];\n        if (obj.type === 'triangle') {\n            const n = obj.value;\n            const h = this.ch / 6;\n            const w = this.cw / 6;\n            const g = this.cw / 12;\n            const l = w * n + g * (n - 1);\n            const dx = (this.cw - l) / 2;\n            const dy = (this.ch - h) / 2;\n            for (let k = 0; k < n; k++) {\n                const x = i * this.cw + dx + k * (w + g);\n                const y = j * this.ch + dy;\n                this.drawTriangle(x, y, x + w, y + h, color);\n            }\n        }\n        else if (obj.type === 'square') {\n            const ctx = this.ctx;\n            const w = this.cw / 3;\n            const dx = (this.cw - w) / 2;\n            const dy = (this.ch - w) / 2;\n            ctx.fillStyle = color;\n            ctx.fillRect(i * this.cw + dx, j * this.ch + dy, w, w);\n        }\n        else if (obj.type === 'tetris') {\n            this.drawTetris(obj.shape, i, j, color, obj.canRotate);\n        }\n        else if (obj.type === 'octagram') {\n            this.drawOctagram(i, j, color);\n        }\n        else if (obj.type === 'nuclear') {\n            this.drawNuclear(i, j, color);\n        }\n    }\n    drawTriangle(x1, y1, x2, y2, color) {\n        const ctx = this.ctx;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.moveTo((x1 + x2) / 2, y2);\n        ctx.lineTo(x1, y1);\n        ctx.lineTo(x2, y1);\n        ctx.fill();\n    }\n    drawNuclear(i, j, color) {\n        const [x, y] = [i * this.cw + this.cw / 2, j * this.ch + this.ch / 2];\n        const r = Math.min(this.cw, this.ch) / 5;\n        const ctx = this.ctx;\n        ctx.strokeStyle = color;\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        ctx.lineWidth = this.rw / 2;\n        const angles = [90, 210, 330];\n        for (const angle of angles) {\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + r * Math.cos(angle * Math.PI / 180), y + r * Math.sin(angle * Math.PI / 180));\n            ctx.stroke();\n        }\n    }\n    drawOctagram(i, j, color) {\n        const [x, y] = [i * this.cw + this.cw / 2, j * this.ch + this.ch / 2];\n        let r = Math.min(this.cw, this.ch) / 5;\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, y + r);\n        this.ctx.lineTo(x - r, y);\n        this.ctx.lineTo(x, y - r);\n        this.ctx.lineTo(x + r, y);\n        this.ctx.fill();\n        r = r * Math.sqrt(2) / 2;\n        this.ctx.beginPath();\n        this.ctx.moveTo(x + r, y + r);\n        this.ctx.lineTo(x - r, y + r);\n        this.ctx.lineTo(x - r, y - r);\n        this.ctx.lineTo(x + r, y - r);\n        this.ctx.fill();\n    }\n    drawTetris(shape, i, j, color, free) {\n        const [bw, bh] = [this.cw / 8, this.ch / 8];\n        const gap = 1;\n        const [, , maxX, maxY] = (0,_shape__WEBPACK_IMPORTED_MODULE_1__.getBounds)(shape);\n        const x0 = (this.cw - (maxX + 1) * bw) / 2 + i * this.cw;\n        const y0 = (this.ch - (maxY + 1) * bh) / 2 + j * this.ch;\n        const xm = i * this.cw + this.cw / 2;\n        const ym = j * this.ch + this.ch / 2;\n        this.ctx.fillStyle = color;\n        const t = this.ctx.getTransform();\n        this.ctx.translate(xm, ym);\n        if (free)\n            this.ctx.rotate(30 * Math.PI / 180);\n        for (const [x, y] of shape) {\n            this.ctx.fillRect(x0 + x * bw - xm, y0 + y * bh - ym, bw - gap, bh - gap);\n        }\n        this.ctx.setTransform(t);\n    }\n    drawHexagon(x, y, radius, color) {\n        this.drawPolygon(x, y, radius, 6, 0, color);\n    }\n    drawPolygon(x, y, radius, n, a1, color) {\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        const angles = [...new Array(n).keys()].map(v => a1 + Math.PI * 2 * v / n);\n        for (let i = 0; i < angles.length; i++) {\n            const a = angles[i];\n            const [vx, vy] = [x + radius * Math.cos(a), y + radius * Math.sin(a)];\n            if (i === 0) {\n                this.ctx.moveTo(vx, vy);\n            }\n            else {\n                this.ctx.lineTo(vx, vy);\n            }\n        }\n        this.ctx.fill();\n    }\n    drawEndPoint() {\n        const ctx = this.ctx;\n        ctx.strokeStyle = this.rc;\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        ctx.lineWidth = this.rw;\n        for (const [x, y] of this.puzzle.endPoints) {\n            const [x1, y1] = this.getExitPoint([x, y]);\n            ctx.beginPath();\n            ctx.moveTo(x * this.cw, y * this.ch);\n            ctx.lineTo(x1, y1);\n            ctx.stroke();\n        }\n    }\n    drawBoard() {\n        this.ctx.fillStyle = this.cc;\n        this.ctx.fillRect(0, 0, this.cw * this.puzzle.m, this.ch * this.puzzle.n);\n    }\n    drawGap(x1, y1, x2, y2) {\n        this.ctx.strokeStyle = this.cc;\n        this.ctx.lineWidth = this.rw + 1;\n        this.ctx.lineCap = 'butt';\n        this.ctx.beginPath();\n        this.ctx.moveTo(x1, y1);\n        this.ctx.lineTo(x2, y2);\n        this.ctx.stroke();\n    }\n    drawRoad() {\n        const [ctx, m, n] = [this.ctx, this.puzzle.m, this.puzzle.n];\n        ctx.strokeStyle = this.rc;\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        ctx.lineWidth = this.rw;\n        ctx.beginPath();\n        for (let i = 0; i < m + 1; i++) {\n            ctx.moveTo(i * this.cw, 0);\n            ctx.lineTo(i * this.cw, n * this.ch);\n        }\n        for (let j = 0; j < n + 1; j++) {\n            ctx.moveTo(0, j * this.ch);\n            ctx.lineTo(m * this.cw, j * this.ch);\n        }\n        ctx.stroke();\n    }\n    calculateCoPath(path, coStart, dir) {\n        const s = path[0];\n        const c = this.translate(coStart);\n        return path.map(v => [(v[0] - s[0]) * dir[0] + c[0], (v[1] - s[1]) * dir[1] + c[1]]);\n    }\n    getAllPaths() {\n        const paths = [this.path];\n        this.coStartPoints.forEach(csp => {\n            paths.push(this.calculateCoPath(this.path, csp.startPoint, csp.dir));\n        });\n        return paths;\n    }\n    drawAllPaths(style = this.lc) {\n        // console.log('draw path by start point: ', JSON.stringify(this.activeStartPoint))\n        this.getAllPaths().forEach(path => this.drawPath(path, style));\n    }\n    drawPath(path, style = this.lc) {\n        const ctx = this.ctx;\n        ctx.strokeStyle = style;\n        ctx.lineJoin = 'round';\n        ctx.lineCap = 'round';\n        this.drawStartPoint(path[0], style);\n        ctx.beginPath();\n        ctx.moveTo(path[0][0], path[0][1]);\n        for (let i = 1; i < path.length; i++) {\n            const [x, y] = path[i];\n            ctx.lineTo(x, y);\n        }\n        ctx.stroke();\n    }\n    insideStartPoint(x, y, p) {\n        return this.distanceLess([x, y], p, this.rw * 1.5);\n    }\n    distanceLess(p1, p2, d) {\n        return this.distance2(p1, p2) < d * d;\n    }\n    distance2(p1, p2) {\n        return (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\n    }\n    findNearestCrossInGrid(m, n, cw, ch, x, y) {\n        let [x1, y1, x2, y2] = _geo__WEBPACK_IMPORTED_MODULE_2__.boundingRectInGrid(x, y, cw, ch);\n        x1 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(x1, 0, m * cw);\n        x2 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(x2, 0, m * cw);\n        y1 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(y1, 0, n * ch);\n        y2 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(y2, 0, n * ch);\n        return _geo__WEBPACK_IMPORTED_MODULE_2__.nearestCornerInRectangle(x, y, x1, y1, x2, y2);\n    }\n    getExitPoint(p) {\n        const [x, y] = p;\n        const m = this.puzzle.m;\n        const n = this.puzzle.n;\n        const l = this.rw;\n        const dx = x === 0 ? -l : (x === m ? l : 0);\n        const dy = y === 0 ? -l : (y === n ? l : 0);\n        return [x * this.cw + dx, y * this.ch + dy];\n    }\n    getEndPoint() {\n        const [x, y] = this.puzzle.endPoints[0];\n        const m = this.puzzle.m;\n        const n = this.puzzle.n;\n        const l = this.rw;\n        const dx = x === 0 ? -l : (x === m ? l : 0);\n        const dy = y === 0 ? -l : (y === n ? l : 0);\n        return [x * this.cw + dx, y * this.ch + dy];\n    }\n    matchEndPoint(point) {\n        return this.puzzle.endPoints.find(p => this.pointEqual(this.getExitPoint(p), point));\n    }\n    findNearestPointInMap(x, y) {\n        // find point in exitPoints which is nearest to (x, y)\n        for (const p of this.puzzle.endPoints) {\n            const q = this.getExitPoint(p);\n            if (this.distanceLess(q, [x, y], this.rw)) {\n                return { nearest: [p[0] * this.cw, p[1] * this.ch], exit: q };\n            }\n        }\n        return {\n            nearest: this.findNearestPointInGrid(this.puzzle.m, this.puzzle.n, this.cw, this.ch, x, y)\n        };\n    }\n    findNearestPointInGrid(m, n, cw, ch, x, y) {\n        let [x1, y1, x2, y2] = _geo__WEBPACK_IMPORTED_MODULE_2__.boundingRectInGrid(x, y, cw, ch);\n        x1 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(x1, 0, m * cw);\n        x2 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(x2, 0, m * cw);\n        y1 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(y1, 0, n * ch);\n        y2 = _geo__WEBPACK_IMPORTED_MODULE_2__.bound(y2, 0, n * ch);\n        return _geo__WEBPACK_IMPORTED_MODULE_2__.nearestPointInRectangle(x, y, x1, y1, x2, y2);\n    }\n    findMaxAllowedEndPoint(x1, y1, x2, y2) {\n        if (!this.saw)\n            return [x2, y2];\n        // console.log(\"findMaxEndPointAvoidingSelfCross: \", x1, y1, x2, y2)\n        const [sw, sh, rw] = [this.cw / 2 | 0, this.ch / 2 | 0, this.rw];\n        // x1 and y1 should be divide by cw and ch\n        if (x2 === x1 && y2 === y1) {\n            return [x2, y2];\n        }\n        const dX = Math.sign(x2 - x1);\n        const dY = Math.sign(y2 - y1);\n        for (let [X, Y] = [Math.floor(x1 / sw) + (dX === 1 ? 1 : 0), Math.floor(y1 / sh) + (dY === 1 ? 1 : 0)];; X += dX, Y += dY) {\n            const [x, y] = [X * sw, Y * sh];\n            const crossed = this.crossSelf(x, y);\n            console.log(`crossed: ${crossed}, ${x}, ${y}, ${X}, ${Y}`);\n            if (X % 2 === 0 && Y % 2 === 0 && crossed) {\n                const gap = this.pointEqual([x, y], this.path[0]) ? this.rw * 1.5 + 5 : this.rw + 5;\n                return [\n                    this.nearest(x1, x2, x - gap * dX),\n                    this.nearest(y1, y2, y - gap * dY)\n                ];\n            }\n            if ((X % 2 === 1 || Y % 2 === 1) && X < 2 * this.puzzle.m + 1 && Y < 2 * this.puzzle.n + 1) {\n                let blockingObjectLength = 0;\n                let obj = this.puzzle.borderObjects[X][Y];\n                if (obj.type === 'gap')\n                    blockingObjectLength = obj.length;\n                for (const csp of this.coStartPoints) {\n                    const XX = (X - this.activeStartPoint[0] * 2) * csp.dir[0] + csp.startPoint[0] * 2;\n                    const YY = (Y - this.activeStartPoint[1] * 2) * csp.dir[1] + csp.startPoint[1] * 2;\n                    obj = this.puzzle.borderObjects[XX][YY];\n                    if (obj.type === 'gap')\n                        blockingObjectLength = obj.length;\n                }\n                if (blockingObjectLength) {\n                    const np = [\n                        this.nearest(x1, x2, x - (sw * 2 - rw) * blockingObjectLength / 2 * dX - this.rw / 2 * dX),\n                        this.nearest(y1, y2, y - (sh * 2 - rw) * blockingObjectLength / 2 * dY - this.rw / 2 * dY)\n                    ];\n                    // console.log(\"gap, \", np)\n                    return np;\n                }\n            }\n            // stop on [x, y] go out of (x1,y1 - x2,y2)\n            if (x1 === x2 && (y - y1) * (y - y2) > 0 || y1 === y2 && (x - x1) * (x - x2) > 0) {\n                // console.log(\"break\")\n                break;\n            }\n        }\n        return [x2, y2];\n    }\n    // 找到两点之间所有的交叉点\n    middleCrosses(x1, y1, x2, y2) {\n        if (x1 === x2) {\n            return this.middleAlignments(y1, y2, this.ch).map(v => [x1, v]);\n        }\n        else {\n            return this.middleAlignments(x1, x2, this.cw).map(v => [v, y1]);\n        }\n    }\n    middleAlignments(x1, x2, w) {\n        const r = [];\n        if (x1 < x2) {\n            for (let x = x1 - x1 % w + w; x < x2; x += w)\n                r.push(x);\n        }\n        else {\n            for (let x = x1 - x1 % w - w; x > x2; x -= w)\n                r.push(x);\n        }\n        return r;\n    }\n    crossSelf(x, y) {\n        for (let i = 0; i < this.path.length - 3; i++) {\n            const [x1, y1] = this.path[i];\n            const [x2, y2] = this.path[i + 1];\n            if (this.pointInLineSegment(x, y, x1, y1, x2, y2))\n                return true;\n        }\n        for (const csp of this.coStartPoints) {\n            const path = this.calculateCoPath([...this.path, [x, y]], csp.startPoint, csp.dir);\n            console.log(`checking copath : ${x}, ${y}`, JSON.stringify(path));\n            for (let i = 0; i < path.length - 1; i++) {\n                const [x1, y1] = path[i];\n                const [x2, y2] = path[i + 1];\n                if (this.pointInLineSegment(x, y, x1, y1, x2, y2)) {\n                    console.log('crossed');\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    getFullPath(p) {\n        const path = [p[0].slice()];\n        for (let i = 0; i < p.length - 2; i++) {\n            const [x1, y1] = p[i];\n            const [x2, y2] = p[i + 1];\n            path.push(...this.middleCrosses(x1, y1, x2, y2));\n            path.push([x2, y2]);\n        }\n        return path.map(v => [v[0] / this.cw, v[1] / this.ch]);\n    }\n    /// limit: x1 == x2 || y1 == y2\n    pointInLineSegment(x, y, x1, y1, x2, y2) {\n        if (x1 === x2 && x === x2) {\n            return (y1 <= y && y <= y2) || (y2 <= y && y <= y1);\n        }\n        if (y1 === y2 && y === y2) {\n            return (x1 <= x && x <= x2) || (x2 <= x && x <= x1);\n        }\n        return false;\n    }\n    nearest(x, x1, x2) {\n        // find which one is nearest from x\n        const c1 = Math.abs(x1 - x);\n        const c2 = Math.abs(x2 - x);\n        return c1 < c2 ? x1 : x2;\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/canvasdrawer.ts?");

/***/ }),

/***/ "./src/geo.ts":
/*!********************!*\
  !*** ./src/geo.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Map\": () => (/* binding */ Map),\n/* harmony export */   \"bound\": () => (/* binding */ bound),\n/* harmony export */   \"boundingRectInGrid\": () => (/* binding */ boundingRectInGrid),\n/* harmony export */   \"nearestCornerInRectangle\": () => (/* binding */ nearestCornerInRectangle),\n/* harmony export */   \"nearestPointInLineSegment\": () => (/* binding */ nearestPointInLineSegment),\n/* harmony export */   \"nearestPointInRectangle\": () => (/* binding */ nearestPointInRectangle)\n/* harmony export */ });\nfunction bound(k, a, b) {\n    return k < a ? a : (k > b ? b : k);\n}\nfunction nearestPointInRectangle(x, y, x1, y1, x2, y2) {\n    const l1 = x - x1;\n    const l2 = x2 - x;\n    const l3 = y - y1;\n    const l4 = y2 - y;\n    const m = Math.min(l1, l2, l3, l4);\n    if (m === l1)\n        return [x1, bound(y, y1, y2)];\n    if (m === l2)\n        return [x2, bound(y, y1, y2)];\n    if (m === l3)\n        return [bound(x, x1, x2), y1];\n    if (m === l4)\n        return [bound(x, x1, x2), y2];\n    // wont reach here\n    return [0, 0];\n}\n/// Get one of the 4 corner points in rect((x1, y1) - (x2, y2)) that is nearest from given point (x, y)\nfunction nearestCornerInRectangle(x, y, x1, y1, x2, y2) {\n    return [\n        x - x1 < x2 - x ? x1 : x2,\n        y - y1 < y2 - y ? y1 : y2\n    ];\n}\n/** Get bounding rect in grid (mxn) for point (x,y) */\nfunction boundingRectInGrid(x, y, m, n) {\n    // dx and dy are positive distance from min-value corner\n    // the doubled % algorithm aims to resolve negative cases\n    // e.g. for x == -33 and m = 10, we want 7 instead of -3\n    const dx = (x % m + m) % m;\n    const dy = (y % n + n) % n;\n    return [x - dx, y - dy, x - dx + m, y - dy + n];\n}\nfunction nearestPointInLineSegment(x, y, x1, y1, x2, y2) {\n    const A = x2 - x1;\n    const B = y2 - y1;\n    if (A === 0 && B === 0)\n        return [x1, y1];\n    const dot = (x - x1) * A + (y - y1) * B;\n    const len2 = A * A + B * B;\n    const t = dot / len2;\n    return [\n        t < 0 ? x1 : (t > 1 ? x2 : x1 + t * A),\n        t < 0 ? y1 : (t > 1 ? y2 : y1 + t * B)\n    ];\n}\nclass Map {\n    vertexes;\n    edges;\n    constructor() {\n        this.vertexes = [];\n        this.edges = [];\n    }\n    addEdge(x1, y1, x2, y2) {\n        const n1 = this.getOrCreateNode(x1, y1);\n        const n2 = this.getOrCreateNode(x2, y2);\n        n1.connects.push(n2);\n        n2.connects.push(n1);\n        this.edges.push([n1, n2]);\n    }\n    getOrCreateNode(x, y) {\n        for (const n of this.vertexes) {\n            if (n.x === x && n.y === y)\n                return n;\n        }\n        const n = {\n            x: x,\n            y: y,\n            connects: []\n        };\n        this.vertexes.push(n);\n        return n;\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/geo.ts?");

/***/ }),

/***/ "./src/log.ts":
/*!********************!*\
  !*** ./src/log.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DisableLogs\": () => (/* binding */ DisableLogs),\n/* harmony export */   \"EnableLogs\": () => (/* binding */ EnableLogs),\n/* harmony export */   \"Log\": () => (/* binding */ Log),\n/* harmony export */   \"Tags\": () => (/* binding */ Tags)\n/* harmony export */ });\nvar Tags;\n(function (Tags) {\n    Tags[\"PathTracking\"] = \"PathTracking\";\n})(Tags || (Tags = {}));\nconst enabledTags = new Set();\nfunction EnableLogs(...tags) {\n    for (const tag of tags) {\n        enabledTags.add(tag);\n    }\n}\nfunction DisableLogs(...tags) {\n    for (const tag of tags) {\n        enabledTags.delete(tag);\n    }\n}\nfunction Log(tag, ...args) {\n    if (Array.isArray(tag)) {\n        for (const t of tag) {\n            if (enabledTags.has(t)) {\n                console.log(...args);\n                return;\n            }\n        }\n    }\n    else {\n        if (enabledTags.has(tag)) {\n            console.log(...args);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/log.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Puzzle\": () => (/* binding */ Puzzle),\n/* harmony export */   \"PuzzleConfig\": () => (/* binding */ PuzzleConfig),\n/* harmony export */   \"checkPath\": () => (/* binding */ checkPath),\n/* harmony export */   \"generatePuzzle\": () => (/* binding */ generatePuzzle),\n/* harmony export */   \"getPredefinedPuzzleConfig\": () => (/* binding */ getPredefinedPuzzleConfig),\n/* harmony export */   \"setContainer\": () => (/* binding */ setContainer),\n/* harmony export */   \"setTheme\": () => (/* binding */ setTheme),\n/* harmony export */   \"showPuzzle\": () => (/* binding */ showPuzzle),\n/* harmony export */   \"showSolution\": () => (/* binding */ showSolution)\n/* harmony export */ });\n/* harmony import */ var _saw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./saw */ \"./src/saw.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape */ \"./src/shape.ts\");\n/* harmony import */ var _canvasdrawer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvasdrawer */ \"./src/canvasdrawer.ts\");\n\n\n\n\n\nlet canvas;\nlet theme = {\n    backgroundColor: 'rgb(40,40,40)',\n    boardColor: 'rgb(30, 128, 30)',\n    secondaryLineColor: 'rgb(0, 0, 0)',\n    roadColor: 'rgb(30, 30, 192)',\n    primaryLineColor: 'rgb(224, 224, 128)',\n    successLineColor: 'rgb(0, 0, 0)',\n    squareColors: [\n        'rgb(0,0,0)',\n        'rgb(255,255,255)',\n        'rgb(224, 64, 64)',\n        'rgb(64, 224, 64)',\n        'rgb(224,224,64)',\n        'rgb(224, 64, 224)',\n        'rgb(64, 224, 224)',\n        'rgb(224, 224, 224)',\n        'rgb(128, 128, 192)',\n    ]\n};\nlet drawer;\nfunction setContainer(e) {\n    canvas = document.createElement('canvas');\n    canvas.width = Math.min(document.body.clientWidth, 500);\n    canvas.height = canvas.width;\n    e.appendChild(canvas);\n    setTheme(theme);\n}\nfunction setTheme(t) {\n    theme = t;\n    drawer = new _canvasdrawer__WEBPACK_IMPORTED_MODULE_3__.CanvasDrawer(canvas, t.backgroundColor, t.boardColor, t.roadColor, t.primaryLineColor, t.squareColors);\n}\nfunction showPuzzle(p) {\n    drawer.setPuzzle(p);\n}\nfunction showSolution() {\n    drawer.drawSolution();\n}\nfunction getPassingNumber(paths, m, n) {\n    const pn = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([m, n], 0);\n    for (const path of paths) {\n        for (let i = 0; i < path.length - 1; i++) {\n            const [x1, y1] = path[i];\n            const [x2, y2] = path[i + 1];\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            // dx=0,dy=-1  [x1-1,y1-1] [x1,y1-1]\n            // dx=0,dy=1   [x1-1,y1] [x1,y1]\n            // dx=-1,dy=0  [x1-1,y1-1] [x1-1,y1]\n            // dx=1,dy=0   [x1,y1-1] [x1, y1]\n            const a1 = dx === 1 ? x1 : x1 - 1;\n            const b1 = dy === 1 ? y1 : y1 - 1;\n            const a2 = dx === -1 ? x1 - 1 : x1;\n            const b2 = dy === -1 ? y1 - 1 : y1;\n            if (a1 >= 0 && b1 >= 0 && a1 < m && b1 < n) {\n                pn[a1][b1]++;\n            }\n            if (a2 >= 0 && b2 >= 0 && a2 < m && b2 < n) {\n                pn[a2][b2]++;\n            }\n        }\n    }\n    return pn;\n}\nfunction pointEqual(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nfunction getRegions(paths, m, n) {\n    const lines = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array3d)([m, n, 2], 0);\n    for (const path of paths) {\n        for (let i = 0; i < path.length - 1; i++) {\n            const x = Math.min(path[i + 1][0], path[i][0]);\n            const y = Math.min(path[i + 1][1], path[i][1]);\n            const dir = path[i + 1][0] - path[i][0] !== 0 ? 0 : 1;\n            lines[x][y][dir] = 1;\n        }\n    }\n    const colors = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([m - 1, n - 1], 0);\n    for (let i = 0; i < m - 1; i++)\n        for (let j = 0; j < n - 1; j++)\n            colors[i][j] = i * (n - 1) + j;\n    const paint = function (colors, m, n, c1, c2) {\n        for (let a = 0; a < m; a++) {\n            for (let b = 0; b < n; b++) {\n                if (colors[a][b] === c2)\n                    colors[a][b] = c1;\n            }\n        }\n    };\n    let merged = false;\n    do {\n        merged = false;\n        for (let i = 0; i < m - 1; i++) {\n            for (let j = 0; j < n - 1; j++) {\n                if (lines[i][j][0] === 0 && j > 0) {\n                    const c1 = colors[i][j];\n                    const c2 = colors[i][j - 1];\n                    if (c1 !== c2) {\n                        paint(colors, m - 1, n - 1, c1, c2);\n                        merged = true;\n                    }\n                }\n                if (lines[i][j][1] === 0 && i > 0) {\n                    const c1 = colors[i][j];\n                    const c2 = colors[i - 1][j];\n                    if (c1 !== c2) {\n                        paint(colors, m - 1, n - 1, c1, c2);\n                        merged = true;\n                    }\n                }\n            }\n        }\n    } while (merged);\n    const regions = {};\n    for (let i = 0; i < m - 1; i++) {\n        for (let j = 0; j < n - 1; j++) {\n            const c = colors[i][j];\n            if (!(c in regions))\n                regions[c] = [];\n            regions[c].push([i, j]);\n        }\n    }\n    return Object.values(regions);\n}\n// get all possible hexagon points inside the region\n// the paths are used to exclude the points that on the border of the region\nfunction getInnerHexagonPoints(paths, region, m, n) {\n    const r = [];\n    const arr = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([m * 2 + 1, n * 2 + 1], 0);\n    for (const [x, y] of region) {\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                arr[x * 2 + i][y * 2 + j]++;\n    }\n    for (const path of paths) {\n        for (let i = 0; i < path.length - 1; i++) {\n            const [x1, y1] = path[i];\n            const [x2, y2] = path[i + 1];\n            arr[x1 * 2][y1 * 2] = -1;\n            arr[x2 * 2][y2 * 2] = -1;\n            arr[x1 + x2][y1 + y2] = -1;\n        }\n    }\n    for (let i = 0; i < m * 2 + 1; i++) {\n        for (let j = 0; j < n * 2 + 1; j++) {\n            if (i % 2 === 0 || j % 2 === 0) {\n                if (arr[i][j] > 0)\n                    r.push([i, j]);\n            }\n        }\n    }\n    return r;\n}\nfunction pathContainsLine(path, x1, y1, x2, y2) {\n    const i1 = path.findIndex(v => pointEqual(v, [x1, y1]));\n    const i2 = path.findIndex(v => pointEqual(v, [x2, y2]));\n    return i1 !== -1 && i2 !== -1 && Math.abs(i1 - i2) === 1;\n}\nfunction splitRegion(r, maxUnitSize) {\n    let m = 1;\n    let n = 1;\n    for (const [x, y] of r) {\n        if (m < x + 1)\n            m = x + 1;\n        if (n < y + 1)\n            n = y + 1;\n    }\n    const color = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([m, n], -1);\n    for (const [x, y] of r) {\n        color[x][y] = x * n + y;\n    }\n    const colorCount = function (c) {\n        let count = 0;\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                if (color[i][j] === c)\n                    count++;\n            }\n        }\n        return count;\n    };\n    const paint = function (c1, c2) {\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                if (color[i][j] === c1)\n                    color[i][j] = c2;\n            }\n        }\n    };\n    while (true) {\n        // find all paint solution, and randomly choose one\n        const paintData = [];\n        for (let i = 0; i < r.length; i++) {\n            const [x, y] = r[i];\n            const cc = colorCount(color[x][y]);\n            const cd = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];\n            for (const [x1, y1] of cd) {\n                if (x1 >= 0 && x1 < m && y1 >= 0 && y1 < n &&\n                    color[x1][y1] !== -1 &&\n                    color[x1][y1] !== color[x][y] &&\n                    colorCount(color[x1][y1]) + cc <= maxUnitSize) {\n                    paintData.push([[x, y], [x1, y1]]);\n                }\n            }\n        }\n        if (paintData.length === 0)\n            break;\n        const i = Math.floor(Math.random() * paintData.length);\n        const [[x, y], [x1, y1]] = paintData[i];\n        paint(color[x][y], color[x1][y1]);\n    }\n    const regions = {};\n    for (const [x, y] of r) {\n        const c = color[x][y];\n        if (!(c in regions))\n            regions[c] = [];\n        regions[c].push([x, y]);\n    }\n    return Object.values(regions);\n}\nfunction normalizeRegion(r) {\n    const [minX, minY] = _shape__WEBPACK_IMPORTED_MODULE_2__.getBounds(r);\n    return r.map(v => [v[0] - minX, v[1] - minY]);\n}\nclass Puzzle {\n    m = 1;\n    n = 1;\n    path = [];\n    cellObjects = [];\n    borderObjects = [];\n    // structure of startPoints: [x1, y1, x2, y2, transformX, transformY]\n    startPoints = [];\n    endPoints = [];\n}\nclass PuzzleConfig {\n    m = 4;\n    n = 4;\n    pathComplexity = 0.5; // 0 - 1, high complexity = large path length\n    triangleCount = 0; // triangle count, 0 === no triangle\n    triangleColorCount = 1; // all triangle has single color\n    squareCount = 0; // square count, 0 === no square\n    squareColorCount = 0; // number of max square color count, 0 === no square\n    hexagonXCount = 0; // hexagon at cross\n    hexagonICount = 0; // hexagon at edge\n    hexagonColorCount = 0; // only happens when there are 2 mirror paths. meaningless now\n    octagramCount = 0;\n    octagramColorCount = 0;\n    gapCount = 0;\n    gapRatio = 0.4;\n    gapLength = 0.3;\n    tetrisRegionCount = 0; //\n    tetrisFreeRatio = 0.5;\n    tetrisMaxParts = 4; //\n    tetrisMinParts = 1;\n    nuclearCount = 0;\n    startPoints = []; //\n    endPoints = [];\n    constructor(o) {\n        Object.assign(this, o);\n    }\n}\nfunction getPredefinedPuzzleConfig() {\n    return [\n        {\n            name: 'Maze',\n            conf: {\n                m: 8, n: 8, gapCount: 70\n            }\n        },\n        {\n            name: 'Parallel Maze',\n            conf: {\n                m: 4, n: 4, gapCount: 4,\n                startPoints: [\n                    [0, 0, 4, 0, -1, 1]\n                ],\n                endPoints: [\n                    [0, 4], [4, 4]\n                ]\n            }\n        },\n        {\n            name: 'Discarded Panels (triangles)',\n            conf: {\n                m: 4, n: 4, triangleCount: 8\n            }\n        },\n        {\n            name: 'Hamilton',\n            conf: {\n                m: 4,\n                n: 4,\n                pathComplexity: 1,\n                hexagonXCount: 100,\n                tetrisRegionCount: 1\n            }\n        },\n        {\n            name: 'Color Separation',\n            conf: {\n                m: 4, n: 4, squareCount: 10, squareColorCount: 3\n            }\n        }\n    ];\n}\n// TODO: consider co-start paths\nfunction generatePuzzle(conf) {\n    const startPoints = conf.startPoints.slice();\n    const endPoints = conf.endPoints.slice();\n    const nullObject = { type: '', color: 0 };\n    // regulate\n    for (const p of startPoints) {\n        if (p[0] > conf.m)\n            p[0] = conf.m;\n        if (p[1] > conf.n)\n            p[1] = conf.n;\n    }\n    for (const p of endPoints) {\n        if (p[0] > conf.m)\n            p[0] = conf.m;\n        if (p[1] > conf.n)\n            p[1] = conf.n;\n    }\n    if (startPoints.length === 0) {\n        startPoints.push([0, 0]);\n    }\n    if (endPoints.length === 0) {\n        endPoints.push([conf.m, conf.n]);\n    }\n    // Get the path\n    const p = new Puzzle();\n    p.m = conf.m;\n    p.n = conf.n;\n    p.cellObjects = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([p.m, p.n], nullObject);\n    p.borderObjects = (0,_util__WEBPACK_IMPORTED_MODULE_1__.array2d)([2 * p.m + 1, 2 * p.n + 1], nullObject);\n    p.startPoints = (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(startPoints.slice());\n    p.endPoints = (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(endPoints.slice());\n    const [x1, y1] = startPoints[0];\n    const [x2, y2] = endPoints[0];\n    const s = new _saw__WEBPACK_IMPORTED_MODULE_0__[\"default\"](p.m + 1, p.n + 1, [x1, y1], [x2, y2]);\n    generateRandomPath(s, conf.pathComplexity);\n    p.path = s.path;\n    const regions = getRegions([p.path], p.m + 1, p.n + 1);\n    // triangles\n    if (conf.triangleCount > 0) {\n        const pn = getPassingNumber([p.path], p.m, p.n);\n        const canFill = [];\n        for (const [x, y] of (0,_util__WEBPACK_IMPORTED_MODULE_1__.range2d)([0, 0], [p.m, p.n])) {\n            if (pn[x][y] > 0 && p.cellObjects[x][y].type === '') {\n                canFill.push([x, y]);\n            }\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(canFill, conf.triangleCount)) {\n            p.cellObjects[x][y] = {\n                type: 'triangle',\n                value: pn[x][y],\n                color: 4\n            };\n        }\n    }\n    // squares\n    if (conf.squareCount > 0) {\n        const colorCount = Math.min(regions.length, conf.squareColorCount);\n        const sr = (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(regions);\n        const d = (0,_util__WEBPACK_IMPORTED_MODULE_1__.ndarray)([p.m, p.n], 0);\n        for (let i = 0; i < sr.length; i++) {\n            const r = sr[i];\n            for (const [x, y] of r) {\n                d[x][y] = 1 + (i % colorCount);\n            }\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(regions.flat(), conf.squareCount)) {\n            p.cellObjects[x][y] = {\n                type: 'square',\n                color: d[x][y]\n            };\n        }\n    }\n    // hexagon\n    if (conf.hexagonXCount > 0 || conf.hexagonICount > 0) {\n        const arrX = [];\n        const arrI = [];\n        for (let i = 0; i < p.path.length - 1; i++) {\n            const [x1, y1] = p.path[i];\n            const [x2, y2] = p.path[i + 1];\n            arrX.push([x2 * 2, y2 * 2]);\n            arrI.push([x1 + x2, y1 + y2]);\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(arrX, conf.hexagonXCount)) {\n            p.borderObjects[x][y] = {\n                type: 'hexagon',\n                color: 0\n            };\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(arrI, conf.hexagonICount)) {\n            p.borderObjects[x][y] = {\n                type: 'hexagon',\n                color: 0\n            };\n        }\n    }\n    // gap\n    if (conf.gapCount > 0) {\n        const arr = [];\n        for (let i = 0; i <= p.m * 2; i++) {\n            for (let j = 0; j <= p.n * 2; j++) {\n                if (i % 2 === 1 && j % 2 === 0) {\n                    const [x1, y1, x2, y2] = [(i - 1) / 2, j / 2, (i + 1) / 2, j / 2];\n                    if (!pathContainsLine(p.path, x1, y1, x2, y2))\n                        arr.push([i, j]);\n                }\n                else if (i % 2 === 0 && j % 2 === 1) {\n                    const [x1, y1, x2, y2] = [i / 2, (j - 1) / 2, i / 2, (j + 1) / 2];\n                    if (!pathContainsLine(p.path, x1, y1, x2, y2))\n                        arr.push([i, j]);\n                }\n            }\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(arr, conf.gapCount)) {\n            p.borderObjects[x][y] = {\n                type: 'gap',\n                length: conf.gapLength\n            };\n        }\n    }\n    // tetris\n    if (conf.tetrisRegionCount > 0) {\n        const tetrisPositions = [];\n        for (const r of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(regions, conf.tetrisRegionCount)) {\n            const subRegions = splitRegion(r, conf.tetrisMaxParts);\n            (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(r);\n            for (let i = 0; i < subRegions.length; i++) {\n                const [x, y] = r[i];\n                p.cellObjects[x][y] = {\n                    type: 'tetris',\n                    shape: normalizeRegion(subRegions[i]),\n                    color: 4,\n                    canRotate: false\n                };\n                tetrisPositions.push([x, y]);\n            }\n        }\n        for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_1__.randomSubset(tetrisPositions, tetrisPositions.length * conf.tetrisFreeRatio)) {\n            const obj = p.cellObjects[x][y];\n            const u = new _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeUnit(_shape__WEBPACK_IMPORTED_MODULE_2__.setToShape(obj.shape, ''), true);\n            console.log(u);\n            if (u.shapes.length > 1) {\n                obj.canRotate = true;\n                obj.shape = _shape__WEBPACK_IMPORTED_MODULE_2__.shapeToSet(u.shapes[u.shapes.length - 1]);\n            }\n        }\n    }\n    // octagrams\n    if (conf.octagramColorCount > 0) {\n        (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(regions);\n        let remainingOctagramCount = conf.octagramCount;\n        const usedColors = new Set();\n        while (remainingOctagramCount > 0) {\n            // iterate regions, for each region, decide to put 1 or 2 octagrams\n            let assigned = false;\n            for (let i = 0; i < regions.length && remainingOctagramCount > 0; i++) {\n                const availableCells = [];\n                let availableSingleColors = [];\n                const occupiedColors = [];\n                let candidateColors = [...usedColors];\n                const colors = {};\n                for (const [x, y] of regions[i]) {\n                    const obj = p.cellObjects[x][y];\n                    if (obj.type === '') {\n                        availableCells.push([x, y]);\n                    }\n                    else {\n                        (0,_util__WEBPACK_IMPORTED_MODULE_1__.incCounter)(colors, obj.color);\n                    }\n                }\n                for (const c in colors) {\n                    if (colors[c] === 1) {\n                        availableSingleColors.push(parseInt(c));\n                    }\n                    else {\n                        occupiedColors.push(parseInt(c));\n                    }\n                }\n                // fill candidate colors\n                for (let i = 0; i < 100 && candidateColors.length < conf.octagramColorCount; i++) {\n                    if (candidateColors.indexOf(i) === -1 && (!(i in colors) || availableSingleColors.indexOf(i) >= 0)) {\n                        candidateColors.push(i);\n                    }\n                }\n                // remove occupied colors from candidate colors\n                candidateColors = candidateColors.filter(c => occupiedColors.indexOf(c) === -1);\n                // limit single colors\n                availableSingleColors = availableSingleColors.filter(c => candidateColors.indexOf(c) >= 0);\n                // console.log(i, regions)\n                // console.log(\"used colors\", usedColors)\n                // console.log(\"colors\", colors, \"occupied colors\", occupiedColors, \"availableSingleColors\", availableSingleColors)\n                // console.log(\"candidateColors\", candidateColors)\n                if (candidateColors.length === 0)\n                    continue;\n                if (remainingOctagramCount === 1 && availableSingleColors.length === 0)\n                    continue;\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(availableCells);\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(availableSingleColors);\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(candidateColors);\n                let octagramCount = 0;\n                // avail-cell     avail-color     allowed-octagram-count\n                // 0              any             0\n                // 1              0               0\n                // 1              >0              1\n                // >1             0               2\n                // >1             >0              1 or 2\n                if (remainingOctagramCount === 1) {\n                    octagramCount = 1;\n                }\n                else if (availableCells.length === 1 && availableSingleColors.length > 0) {\n                    octagramCount = 1;\n                }\n                else if (availableCells.length > 1 && availableSingleColors.length === 0) {\n                    octagramCount = 2;\n                }\n                else if (availableCells.length > 1 && availableSingleColors.length > 1) {\n                    octagramCount = Math.random() > 0.5 ? 1 : 2;\n                }\n                if (octagramCount === 1) {\n                    const [x, y] = availableCells[0];\n                    p.cellObjects[x][y] = {\n                        type: 'octagram',\n                        color: availableSingleColors[0]\n                    };\n                    usedColors.add(availableSingleColors[0]);\n                    remainingOctagramCount--;\n                    assigned = true;\n                }\n                else if (octagramCount === 2) {\n                    const [x1, y1] = availableCells[0];\n                    const [x2, y2] = availableCells[1];\n                    p.cellObjects[x1][y1] = {\n                        type: 'octagram',\n                        color: candidateColors[0]\n                    };\n                    p.cellObjects[x2][y2] = {\n                        type: 'octagram',\n                        color: candidateColors[0]\n                    };\n                    usedColors.add(candidateColors[0]);\n                    remainingOctagramCount -= 2;\n                    assigned = true;\n                }\n            }\n            if (!assigned)\n                break;\n        }\n    }\n    // nuclear\n    if (conf.nuclearCount > 0) {\n        (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(regions);\n        let nuclearCount = 0;\n        for (let i = 0; i < regions.length && nuclearCount < conf.nuclearCount; i++) {\n            const region = regions[i];\n            // there can be only one nuclear per region\n            const availableActions = new Set();\n            const emptyCells = [];\n            let squareColor = -1;\n            const octagramColors = [];\n            for (const [x, y] of region) {\n                if (p.cellObjects[x][y].type === '') {\n                    emptyCells.push([x, y]);\n                }\n            }\n            if (emptyCells.length < 1) {\n                console.log('no empty cells');\n                continue;\n            }\n            if (region.length > 1 && conf.hexagonICount + conf.hexagonXCount > 0) {\n                availableActions.add('addHexagon');\n            }\n            for (const [x, y] of region) {\n                const obj = p.cellObjects[x][y];\n                if (obj.type === '')\n                    continue;\n                if (obj.type === 'triangle') {\n                    availableActions.add('changeTriangle');\n                }\n                else if (obj.type === 'square') {\n                    if (emptyCells.length > 1) {\n                        availableActions.add('addSquare');\n                    }\n                    squareColor = obj.color;\n                }\n                else if (obj.type === 'tetris') {\n                    if (emptyCells.length > 1) {\n                        availableActions.add('addTetris');\n                    }\n                }\n                else if (obj.type === 'octagram') {\n                    if (emptyCells.length > 1) {\n                        availableActions.add('addOctagram');\n                    }\n                    octagramColors.push(obj.color);\n                }\n            }\n            console.log('availableActions:', availableActions);\n            if (availableActions.size === 0)\n                continue;\n            (0,_util__WEBPACK_IMPORTED_MODULE_1__.shuffle)(emptyCells);\n            let nuclearPos = 1;\n            const nuclearColor = 1;\n            const action = (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)([...availableActions]);\n            console.log('actions: ', availableActions, ' action: ', action, ' emptyCells', emptyCells);\n            if (action === 'addHexagon') {\n                // get all \"inner border points\"\n                const points = getInnerHexagonPoints([p.path], region, p.m, p.n);\n                const [x, y] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)(points);\n                console.log(points, x, y);\n                p.borderObjects[x][y] = {\n                    type: 'hexagon',\n                    color: 0\n                };\n                nuclearPos = 0;\n            }\n            else if (action === 'changeTriangle') {\n                const [x, y] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)(region.filter(([x, y]) => p.cellObjects[x][y] && p.cellObjects[x][y].type === 'triangle'));\n                const o = p.cellObjects[x][y];\n                console.log(`change triangle at ${x},${y}, value: ${o.value}`);\n                const arr = [1, 2, 3].filter(v => v !== o.value);\n                o.value = (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)(arr);\n                console.log(`new value: ${arr} -> ${o.value}`);\n                nuclearPos = 0;\n            }\n            else if (action === 'addSquare') {\n                const squareColors = new Set();\n                for (let i = 0; i < p.m; i++) {\n                    for (let j = 0; j < p.n; j++) {\n                        const o = p.cellObjects[i][j];\n                        if (o && o.type === 'square')\n                            squareColors.add(o.color);\n                    }\n                }\n                const [x, y] = emptyCells[0];\n                p.cellObjects[x][y] = {\n                    type: 'square',\n                    color: (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)([...squareColors].filter(v => v !== squareColor))\n                };\n                console.log(squareColors, squareColor);\n            }\n            else if (action === 'addTetris') {\n                const [x, y] = emptyCells[0];\n                const ts = _shape__WEBPACK_IMPORTED_MODULE_2__.shapesFromString('1x1 2x2 1x3 3x1 1x4 4x1 L Lcw Lccw L180 J Jcw Jccw J180');\n                p.cellObjects[x][y] = {\n                    type: 'tetris',\n                    color: 4,\n                    shape: (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)(ts.map(v => _shape__WEBPACK_IMPORTED_MODULE_2__.shapeToSet(v)))\n                };\n            }\n            else if (action === 'addOctagram') {\n                const [x, y] = emptyCells[0];\n                p.cellObjects[x][y] = {\n                    type: 'octagram',\n                    color: (0,_util__WEBPACK_IMPORTED_MODULE_1__.randomPickOne)(octagramColors)\n                };\n            }\n            const [nx, ny] = emptyCells[nuclearPos];\n            p.cellObjects[nx][ny] = {\n                type: 'nuclear',\n                color: nuclearColor\n            };\n            nuclearCount++;\n        }\n    }\n    return p;\n}\nfunction generateRandomPath(s, c) {\n    const tryCount = 100;\n    const backDepth = 5;\n    let maxLen = s.m * s.n;\n    // parity\n    // given M,N and start/end point, is there a path passing by all points?\n    // or there is always 1 point left?\n    // conjecture:\n    // if parity(y2-y1+x2-x1) !== parity(M*N-1) then we have to leave 1 point not passed\n    const p1 = s.path[0];\n    const p2 = s.path[s.path.length - 1];\n    if ((p1[0] + p1[1] + p2[0] + p2[1] + s.m * s.n + 1) % 2 === 1) {\n        maxLen--;\n    }\n    // initial random shift,\n    // resolve corner cases such as 2x2 saw\n    const irs = Math.random() * 10;\n    for (let i = 0; i < irs; i++) {\n        s.randomShift();\n    }\n    // try getting longest\n    for (let i = 0; i < tryCount; i++) {\n        if (s.path.length < maxLen) {\n            for (let j = 0; j < backDepth; j++) {\n                s.randomShift(v => v.type !== 3);\n            }\n            while (s.randomShift(v => v.type === 0))\n                ;\n        }\n        else {\n            break;\n        }\n    }\n    // reduce to target length\n    // the reason why we get longest and reduce, instead of stopping at target length, is that\n    // we want to keep the path as random as possible\n    if (c < 0)\n        c = 0;\n    if (c > 1)\n        c = 1;\n    const minLen = Math.abs(p2[0] - p1[0]) + Math.abs(p2[1] - p1[1]) + 1;\n    const targetLen = minLen + (maxLen - minLen) * c;\n    let count = 10000;\n    while (s.path.length > targetLen && count >= 0) {\n        s.randomShift(v => v.type !== 0);\n        count--;\n    }\n}\nfunction checkPath(p, paths, checkNuclear) {\n    const pn = getPassingNumber(paths, p.m, p.n);\n    const regions = getRegions(paths, p.m + 1, p.n + 1);\n    const checkRegion = function (region, cellObjects, borderObjects) {\n        console.log('check region:', region, cellObjects, borderObjects);\n        const foreachInRegion = function (region, cellObjects, f) {\n            for (const [x, y] of region) {\n                const obj = cellObjects[x][y];\n                if (obj.type !== '')\n                    f(x, y, obj);\n            }\n        };\n        let result = [];\n        // triangles\n        foreachInRegion(region, cellObjects, (x, y, obj) => {\n            if (obj.type === 'triangle' && pn[x][y] !== obj.value) {\n                result.push([2 * x + 1, 2 * y + 1]);\n            }\n        });\n        // squares\n        const squareColors = new Set();\n        const squares = [];\n        foreachInRegion(region, cellObjects, (x, y, obj) => {\n            if (obj.type === 'square') {\n                squares.push([2 * x + 1, 2 * y + 1]);\n                squareColors.add(obj.color);\n            }\n        });\n        if (squareColors.size > 1)\n            result.push(...squares);\n        // hexagons\n        const points = getInnerHexagonPoints(paths, region, p.m, p.n);\n        for (const [x, y] of points) {\n            const obj = borderObjects[x][y];\n            if (obj && obj.type === 'hexagon')\n                result.push([x, y]);\n        }\n        // tetris\n        const s = _shape__WEBPACK_IMPORTED_MODULE_2__.setToShape(region, '');\n        const ss = [];\n        const tetrises = [];\n        foreachInRegion(region, cellObjects, (x, y, obj) => {\n            if (obj.type === 'tetris') {\n                const tetrisObj = obj;\n                ss.push(new _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeUnit(_shape__WEBPACK_IMPORTED_MODULE_2__.setToShape(tetrisObj.shape, ''), tetrisObj.canRotate));\n                tetrises.push([2 * x + 1, 2 * y + 1]);\n            }\n        });\n        if (ss.length > 0 && !_shape__WEBPACK_IMPORTED_MODULE_2__.checkComposition(s, ss)) {\n            result.push(...tetrises);\n        }\n        // octagrams\n        const colors = {};\n        foreachInRegion(region, cellObjects, (x, y, obj) => {\n            (0,_util__WEBPACK_IMPORTED_MODULE_1__.incCounter)(colors, obj.color);\n        });\n        foreachInRegion(region, cellObjects, (x, y, obj) => {\n            if (obj.type === 'octagram' && colors[obj.color] !== 2)\n                result.push([2 * x + 1, 2 * y + 1]);\n        });\n        console.log('check result:', JSON.stringify(result));\n        // nuclears\n        // nuclears cannot dismiss each other\n        if (checkNuclear) {\n            const nuclears = [];\n            foreachInRegion(region, cellObjects, (x, y, obj) => {\n                if (obj.type === 'nuclear') {\n                    nuclears.push([2 * x + 1, 2 * y + 1]);\n                }\n            });\n            if (nuclears.length > result.length) {\n                result.push(...nuclears);\n            }\n            else if (nuclears.length > 0) {\n                const indexes = result.map((v, i) => i < nuclears.length ? 0 : 1);\n                let corrected = false;\n                do {\n                    const removedPos = (0,_util__WEBPACK_IMPORTED_MODULE_1__.ndarray)([p.m * 2 + 1, p.n * 2 + 1], 0);\n                    nuclears.forEach(([x, y]) => {\n                        removedPos[x][y] = 1;\n                    });\n                    indexes.forEach((x, i) => {\n                        if (x === 0) {\n                            const [a, b] = result[i];\n                            removedPos[a][b] = 1;\n                        }\n                    });\n                    console.log('removed pos', JSON.stringify(removedPos));\n                    const newCellObjects = (0,_util__WEBPACK_IMPORTED_MODULE_1__.ndarray)([p.m, p.n], null);\n                    const newBorderObjects = (0,_util__WEBPACK_IMPORTED_MODULE_1__.ndarray)([p.m * 2 + 1, p.n * 2 + 1], null);\n                    for (let i = 0; i <= p.m * 2; i++) {\n                        for (let j = 0; j <= p.n * 2; j++) {\n                            if (removedPos[i][j] === 1)\n                                continue;\n                            if (i % 2 === 1 && j % 2 === 1) {\n                                newCellObjects[(i - 1) / 2][(j - 1) / 2] = cellObjects[(i - 1) / 2][(j - 1) / 2];\n                            }\n                            else {\n                                newBorderObjects[i][j] = borderObjects[i][j];\n                            }\n                        }\n                    }\n                    const r = checkRegion(region, newCellObjects, newBorderObjects);\n                    if (r.length === 0) {\n                        corrected = true;\n                        break;\n                    }\n                } while ((0,_util__WEBPACK_IMPORTED_MODULE_1__.nextPermutation)(indexes));\n                if (corrected) {\n                    console.log('corrected');\n                    result = [];\n                }\n                else {\n                    result.push(...nuclears);\n                }\n            }\n        }\n        console.log('check result:', result);\n        return result;\n    };\n    const result = [];\n    for (const region of regions) {\n        result.push(...checkRegion(region, p.cellObjects, p.borderObjects));\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/main.ts?");

/***/ }),

/***/ "./src/saw.ts":
/*!********************!*\
  !*** ./src/saw.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SAW)\n/* harmony export */ });\n/** SAW (self avoiding walk) generation\n *  by random shifts based on the initial path\n */\nclass SAW {\n    m;\n    n;\n    path;\n    constructor(m, n, p1, p2) {\n        this.m = m;\n        this.n = n;\n        this.path = [];\n        const [x1, y1] = p1;\n        const [x2, y2] = p2;\n        const dx = Math.sign(x2 - x1);\n        const dy = Math.sign(y2 - y1);\n        for (let i = x1; i < x2; i += dx) {\n            this.path.push([i, y1]);\n        }\n        for (let j = y1; j < y2; j += dy) {\n            this.path.push([x2, j]);\n        }\n        this.path.push([x2, y2]);\n    }\n    indexOf(x, y) {\n        for (let i = 0; i < this.path.length; i++) {\n            if (this.path[i][0] === x && this.path[i][1] === y) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    randomShift(filterFunc) {\n        let edges = this.getAllShiftData();\n        if (filterFunc)\n            edges = edges.filter(filterFunc);\n        if (edges.length === 0)\n            return false;\n        const i = Math.floor(Math.random() * edges.length);\n        const e = edges[i];\n        this.shift(e);\n        return true;\n    }\n    shift(e) {\n        // console.log(e)\n        if (e.type === 0)\n            this.path.splice(e.index + 1, 0, e.q1, e.q2);\n        if (e.type === 1)\n            this.path.splice(e.index, 1, e.q2);\n        if (e.type === 2)\n            this.path.splice(e.index + 1, 1, e.q1);\n        if (e.type === 3)\n            this.path.splice(e.index, 2);\n    }\n    getAllShiftData() {\n        const data = [];\n        for (let i = 0; i < this.path.length - 1; i++) {\n            const d1 = this.getShiftData(i, -1);\n            if (d1 !== null)\n                data.push(d1);\n            const d2 = this.getShiftData(i, 1);\n            if (d2 !== null)\n                data.push(d2);\n        }\n        return data;\n    }\n    /** get shift data: target points and type\n      shiftData: {index:2, q1, q2, type: 0/1/2/3}\n    */\n    getShiftData(c, d) {\n        const p1 = this.path[c];\n        const p2 = this.path[c + 1];\n        const sx = Math.sign(p2[0] - p1[0]);\n        const sy = Math.sign(p2[1] - p1[1]);\n        const q1 = [p1[0] + d * sy, p1[1] + d * sx];\n        const q2 = [p2[0] + d * sy, p2[1] + d * sx];\n        if (q1[0] < 0 || q1[0] >= this.m ||\n            q1[1] < 0 || q1[1] >= this.n)\n            return null;\n        const iq1 = this.indexOf(q1[0], q1[1]);\n        const iq2 = this.indexOf(q2[0], q2[1]);\n        // target point type:\n        // available / neighbor / occupied\n        const t1 = iq1 === -1 ? 0 : (iq1 === c - 1) ? 1 : 2;\n        const t2 = iq2 === -1 ? 0 : (iq2 === c + 2) ? 1 : 2;\n        if (t1 === 2 || t2 === 2)\n            return null;\n        return {\n            index: c,\n            q1: q1,\n            q2: q2,\n            type: t1 + t2 * 2\n        };\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/saw.ts?");

/***/ }),

/***/ "./src/settings.ts":
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PuzzleToString\": () => (/* binding */ PuzzleToString),\n/* harmony export */   \"getPuzzleConfig\": () => (/* binding */ getPuzzleConfig),\n/* harmony export */   \"showSettingsPage\": () => (/* binding */ showSettingsPage)\n/* harmony export */ });\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n\n\n\nlet puzzleConfig;\nfunction getPuzzleConfig() {\n    if (puzzleConfig === undefined) {\n        if (window.localStorage.puzzleConfig) {\n            puzzleConfig = JSON.parse(window.localStorage.puzzleConfig);\n        }\n        else {\n            puzzleConfig = new _main__WEBPACK_IMPORTED_MODULE_1__.PuzzleConfig({\n                m: 4,\n                n: 4,\n                squareCount: 10,\n                squareColorCount: 4,\n                gapCount: 5\n            });\n        }\n    }\n    return puzzleConfig;\n}\nfunction savePuzzleConfig(cfg) {\n    puzzleConfig = cfg;\n    window.localStorage.puzzleConfig = JSON.stringify(cfg, null, 4);\n}\nfunction showSettingsPage(applyHandler) {\n    let cfg = { ...getPuzzleConfig() };\n    const sp = _ui__WEBPACK_IMPORTED_MODULE_0__.createModel();\n    document.body.appendChild(sp.layer);\n    const header = document.createElement('div');\n    header.style.backgroundColor = '#F1C9D9';\n    header.style.paddingLeft = '5px';\n    sp.content.appendChild(header);\n    const prop = document.createElement('div');\n    prop.style.padding = '10px';\n    sp.content.appendChild(prop);\n    createSettingContent(prop, cfg);\n    for (const x of _main__WEBPACK_IMPORTED_MODULE_1__.getPredefinedPuzzleConfig()) {\n        const btn = _ui__WEBPACK_IMPORTED_MODULE_0__.appendButton(header, x.name, () => {\n            cfg = new _main__WEBPACK_IMPORTED_MODULE_1__.PuzzleConfig(x.conf);\n            createSettingContent(prop, cfg);\n        });\n        btn.style.margin = '10px 5px';\n    }\n    const footer = document.createElement('div');\n    sp.content.appendChild(footer);\n    footer.style.backgroundColor = '#F1C9D9';\n    footer.style.textAlign = 'center';\n    const btn = _ui__WEBPACK_IMPORTED_MODULE_0__.appendButton(footer, 'APPLY', () => {\n        sp.layer.remove();\n        savePuzzleConfig(cfg);\n        applyHandler(cfg);\n    });\n    btn.style.margin = '10px 0px';\n    sp.layer.onclick = function (e) {\n        const t = e.target;\n        if (t === sp.layer) {\n            sp.layer.remove();\n        }\n    };\n}\nfunction createSettingContent(e, cfg) {\n    e.innerHTML = '';\n    // const tbl = document.createElement('table')\n    // e.append(tbl)\n    const createInput = (prop) => {\n        const obj = cfg;\n        const div = document.createElement('div');\n        div.style.display = 'inline-block';\n        const hint = document.createElement('span');\n        hint.style.marginRight = '5px';\n        const input = document.createElement('input');\n        hint.textContent = prop;\n        input.value = JSON.stringify(obj[prop]);\n        input.onchange = e => {\n            if (typeof obj[prop] === 'number') {\n                obj[prop] = parseFloat(input.value);\n                if (isNaN(obj[prop])) {\n                    obj[prop] = 0;\n                }\n            }\n            else if (typeof obj[prop] === 'string') {\n                obj[prop] = input.value + '';\n            }\n            else if (typeof obj[prop] === 'object' && obj[prop] instanceof Array) {\n                obj[prop] = JSON.parse(input.value);\n            }\n        };\n        div.append(hint);\n        div.append(input);\n        return div;\n    };\n    const createInputGroup = (color, props) => {\n        const div = document.createElement('div');\n        div.style.display = 'flex';\n        div.style.padding = '10px';\n        div.style.flexDirection = 'row';\n        div.style.flexWrap = 'wrap';\n        div.style.gap = '10px';\n        div.style.marginBottom = '5px';\n        div.style.borderBottom = '1px solid #ccc';\n        // div.style.backgroundColor = color\n        for (const p of props) {\n            div.append(createInput(p));\n        }\n        return div;\n    };\n    e.append(createInputGroup('hsl(0, 0%, 95%)', ['m', 'n', 'pathComplexity']));\n    e.append(createInputGroup('hsl(120, 0%, 95%)', ['squareCount', 'squareColorCount']));\n    e.append(createInputGroup('hsl(240, 0%, 95%)', ['gapCount', 'gapRatio', 'gapLength']));\n    e.append(createInputGroup('hsl(60, 0%, 95%)', ['triangleCount', 'triangleColorCount']));\n    e.append(createInputGroup('hsl(180, 0%, 95%)', ['hexagonICount', 'hexagonXCount', 'hexagonColorCount']));\n    e.append(createInputGroup('hsl(270, 0%, 95%)', ['octagramCount', 'octagramColorCount']));\n    e.append(createInputGroup('hsl(30, 0%, 95%)', ['tetrisRegionCount', 'tetrisFreeRatio', 'tetrisMaxParts', 'tetrisMinParts']));\n    e.append(createInputGroup('hsl(150, 0%, 95%)', ['nuclearCount']));\n    e.append(createInputGroup('hsl(210, 0%, 95%)', ['startPoints', 'endPoints']));\n}\nconst poMap = {\n    S: 'square',\n    square: 'S',\n    G: 'gap',\n    gap: 'G',\n    hexagon: 'H',\n    H: 'hexagon',\n    triangle: '3',\n    3: 'triangle',\n    tetris: 'T',\n    T: 'tetris',\n    nuclear: 'N',\n    N: 'nuclear',\n    octagram: 'O',\n    O: 'octagram'\n};\nfunction PuzzleToString(p) {\n    const p2s = (p) => `${p[0]},${p[1]}`;\n    const pa2s = (pa) => pa.map(v => p2s(v)).join(';');\n    const m = {};\n    for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_2__.range2d([0, 0], [p.m, p.n])) {\n        const o = p.cellObjects[x][y];\n        if (o.type !== '') {\n            const t = poMap[o.type];\n            if (t in m) {\n                m[t].push([x, y]);\n            }\n            else {\n                m[t] = [[x, y]];\n            }\n        }\n    }\n    for (const [x, y] of _util__WEBPACK_IMPORTED_MODULE_2__.range2d([0, 0], [p.m * 2, p.n * 2])) {\n        const o = p.borderObjects[x][y];\n        if (o.type !== '') {\n            const t = poMap[o.type];\n            if (t in m) {\n                m[t].push([x, y]);\n            }\n            else {\n                m[t] = [[x, y]];\n            }\n        }\n    }\n    let sm = '';\n    for (const k of Object.keys(m)) {\n        sm += `${k}:${pa2s(m[k])}`;\n    }\n    return `${p.m} ${p.n} ${pa2s(p.startPoints)} ${pa2s(p.endPoints)} ${sm}`;\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/settings.ts?");

/***/ }),

/***/ "./src/shape.ts":
/*!**********************!*\
  !*** ./src/shape.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shape\": () => (/* binding */ Shape),\n/* harmony export */   \"ShapeUnit\": () => (/* binding */ ShapeUnit),\n/* harmony export */   \"checkComposition\": () => (/* binding */ checkComposition),\n/* harmony export */   \"compareShape\": () => (/* binding */ compareShape),\n/* harmony export */   \"getBounds\": () => (/* binding */ getBounds),\n/* harmony export */   \"getTranslated\": () => (/* binding */ getTranslated),\n/* harmony export */   \"rigidTranslate\": () => (/* binding */ rigidTranslate),\n/* harmony export */   \"setToShape\": () => (/* binding */ setToShape),\n/* harmony export */   \"shapeFromAlias\": () => (/* binding */ shapeFromAlias),\n/* harmony export */   \"shapeToSet\": () => (/* binding */ shapeToSet),\n/* harmony export */   \"shapesFromString\": () => (/* binding */ shapesFromString)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n\nclass Shape {\n    m;\n    n;\n    name;\n    data;\n    constructor(m, n, d, name) {\n        this.m = m;\n        this.n = n;\n        this.name = name;\n        if (typeof d === 'number') {\n            this.data = (0,_util__WEBPACK_IMPORTED_MODULE_0__.ndarray)([m, n], d);\n        }\n        else {\n            this.data = d;\n        }\n    }\n    size() {\n        let r = 0;\n        for (let i = 0; i < this.m; i++) {\n            for (let j = 0; j < this.n; j++) {\n                if (this.data[i][j] === 1)\n                    r++;\n            }\n        }\n        return r;\n    }\n    set(v, ...p) {\n        for (let i = 0; i + 1 < p.length; i += 2) {\n            this.data[p[i]][p[i + 1]] = v;\n        }\n        return this;\n    }\n}\nclass ShapeUnit {\n    canRotate;\n    shapes;\n    constructor(s, canRotate) {\n        this.canRotate = canRotate;\n        this.shapes = [s];\n        if (this.canRotate) {\n            const shapes = [\n                s,\n                rigidTranslate(s, 'cw'),\n                rigidTranslate(s, 'ccw'),\n                rigidTranslate(s, '180')\n            ].sort((a, b) => compareShape(a, b));\n            this.shapes = (0,_util__WEBPACK_IMPORTED_MODULE_0__.unique)(shapes, compareShape);\n        }\n    }\n}\nfunction rigidTranslate(s, name) {\n    const newName = s.name + name;\n    switch (name) {\n        case 'cw': return getTranslated(s, newName, true, (x, y) => [y, s.m - 1 - x]);\n        case 'ccw': return getTranslated(s, newName, true, (x, y) => [s.n - 1 - y, x]);\n        case '180': return getTranslated(s, newName, false, (x, y) => [s.m - 1 - x, s.n - 1 - y]);\n        case 's0': return getTranslated(s, newName, false, (x, y) => [x, s.n - 1 - y]);\n        case 's90': return getTranslated(s, newName, false, (x, y) => [s.m - 1 - x, y]);\n        case 's45': return getTranslated(s, newName, true, (x, y) => [y, x]);\n        case 's135': return getTranslated(s, newName, true, (x, y) => [s.n - 1 - y, s.m - 1 - x]);\n        default: return getTranslated(s, newName, false, (x, y) => [x, y]);\n    }\n}\nfunction getTranslated(s, name, e, f) {\n    const r = new Shape(e ? s.n : s.m, e ? s.m : s.n, 0, name);\n    for (let i = 0; i < s.m; i++) {\n        for (let j = 0; j < s.n; j++) {\n            const [ii, jj] = f(i, j);\n            r.data[ii][jj] = s.data[i][j];\n        }\n    }\n    return r;\n}\nfunction shapeFromAlias(a) {\n    const arr = a.split('x');\n    if (arr.length === 2) {\n        return new Shape(parseInt(arr[0]), parseInt(arr[1]), 1, a);\n    }\n    const p = 1;\n    let s = null;\n    if (a.startsWith('L')) {\n        s = new Shape(2, 3, 1).set(0, 1, 0, 1, 1);\n    }\n    else if (a.startsWith('Z')) {\n        s = new Shape(3, 2, 1).set(0, 2, 0, 0, 1);\n    }\n    else if (a.startsWith('T')) {\n        s = new Shape(3, 2, 1).set(0, 0, 1, 2, 1);\n    }\n    else if (a.startsWith('O')) {\n        s = new Shape(2, 2, 1);\n    }\n    else if (a.startsWith('J')) {\n        s = new Shape(2, 3, 1).set(0, 0, 0, 0, 1);\n    }\n    else if (a.startsWith('S')) {\n        s = new Shape(3, 2, 1).set(0, 0, 0, 2, 1);\n    }\n    else if (a.startsWith('I')) {\n        s = new Shape(1, 4, 1);\n    }\n    if (s === null) {\n        throw new Error(`unknown shape alias: ${a}`);\n    }\n    s.name = a.slice(0, p);\n    if (a.length > 1) {\n        s = rigidTranslate(s, a.slice(1));\n    }\n    return s;\n}\nfunction shapesFromString(s) {\n    return s.split(' ').map(a => shapeFromAlias(a));\n}\nfunction compareShape(a, b) {\n    if (a.m < b.m)\n        return -1;\n    if (a.m > b.m)\n        return 1;\n    if (a.n < b.n)\n        return -1;\n    if (a.n > b.n)\n        return 1;\n    for (let i = 0; i < a.m; i++) {\n        for (let j = 0; j < a.n; j++) {\n            if (a.data[i][j] < b.data[i][j])\n                return -1;\n            if (a.data[i][j] > b.data[i][j])\n                return 1;\n        }\n    }\n    return 0;\n}\nfunction checkCompositionInOrder(s, ss) {\n    // shape for current placement\n    const r = (0,_util__WEBPACK_IMPORTED_MODULE_0__.ndarray)([s.m, s.n], 0);\n    const undoPaint = function (shape, x, y, i, j) {\n        const k = i * shape.n + j;\n        for (let a = 0; a < shape.m; a++) {\n            for (let b = 0; b < shape.n; b++) {\n                if (a * shape.n + b >= k)\n                    return;\n                r[x + a][y + b] -= shape.data[a][b];\n            }\n        }\n    };\n    // try paint {shape} to r, if paint result to overlap, or value that s doesn't have\n    // redo the middle-way work and return false\n    const tryPaint = function (shape, x, y) {\n        if (x + shape.m > s.m || y + shape.n > s.n)\n            return false;\n        for (let i = 0; i < shape.m; i++) {\n            for (let j = 0; j < shape.n; j++) {\n                const c1 = shape.data[i][j];\n                const c2 = r[x + i][y + j];\n                const c3 = s.data[x + i][y + j];\n                if (c1 + c2 > c3) {\n                    // wrong color: roll back and return\n                    undoPaint(shape, x, y, i, j);\n                    return false;\n                }\n                else {\n                    r[x + i][y + j] += c1;\n                }\n            }\n        }\n        return true;\n    };\n    const forward = function (p, m, n) {\n        p[1]++;\n        if (p[1] + n > s.n) {\n            p[1] = 0;\n            p[0]++;\n            if (p[0] + m > s.m) {\n                return false;\n            }\n        }\n        return true;\n    };\n    function ready(p) {\n        const [x, y] = p;\n        return r[x][y] === s.data[x][y];\n    }\n    function findNextPlacement(s, p) {\n        let tryNextShape = false;\n        if (!ready(p.currentPosition)) {\n            tryNextShape = true;\n        }\n        else {\n            if (!forward(p.currentPosition, s.shapes[p.rotateIndex].m, s.shapes[p.rotateIndex].n)) {\n                tryNextShape = true;\n            }\n        }\n        if (tryNextShape) {\n            p.rotateIndex++;\n            if (p.rotateIndex === s.shapes.length)\n                return false;\n            p.currentPosition = [...p.initialPosition];\n        }\n        return true;\n    }\n    // witch each shape sequence, we paint shapes to r one by one, position by position\n    // check at the same time and undo paint then try next position\n    const ps = new Array(ss.length);\n    ps[0] = { initialPosition: [0, 0], currentPosition: [0, 0], rotateIndex: 0 };\n    let index = 0;\n    while (true) {\n        // paint the #{index} one\n        const p = ps[index];\n        const res = tryPaint(ss[index].shapes[p.rotateIndex], p.currentPosition[0], p.currentPosition[1]);\n        if (res) {\n            // console.log(`paint ${ss[index].name} at ${ps[index]}`)\n            // console.log(r)\n            index++;\n            if (index === ss.length)\n                return true;\n            ps[index] = { initialPosition: [...ps[index - 1].currentPosition], currentPosition: [...ps[index - 1].currentPosition], rotateIndex: 0 };\n        }\n        else {\n            while (true) {\n                if (findNextPlacement(ss[index], ps[index])) {\n                    break;\n                }\n                if (index === 0)\n                    return false;\n                index--;\n                undoPaint(ss[index].shapes[ps[index].rotateIndex], ps[index].currentPosition[0], ps[index].currentPosition[1], ss[index].shapes[ps[index].rotateIndex].m, ss[index].shapes[ps[index].rotateIndex].n);\n            }\n        }\n    }\n}\nfunction checkComposition(s, units) {\n    const c1 = s.size();\n    const c2 = units.reduce((p, c) => p + c.shapes[0].size(), 0);\n    if (c1 !== c2)\n        return false;\n    const sortedUnits = [...units].sort((a, b) => compareShape(a.shapes[0], b.shapes[0]));\n    // outer loop, through all shape permutations\n    do {\n        // console.log(ss.map(v=>v.name))\n        if (checkCompositionInOrder(s, sortedUnits))\n            return true;\n    } while ((0,_util__WEBPACK_IMPORTED_MODULE_0__.nextPermutation)(sortedUnits, (a, b) => compareShape(a.shapes[0], b.shapes[0]) < 0));\n    return false;\n}\nfunction setToShape(r, name) {\n    const [minX, minY, maxX, maxY] = getBounds(r);\n    const [m, n] = [maxX - minX + 1, maxY - minY + 1];\n    const data = (0,_util__WEBPACK_IMPORTED_MODULE_0__.array2d)([m, n], 0);\n    for (const [x, y] of r) {\n        data[x - minX][y - minY] = 1;\n    }\n    return new Shape(m, n, data, name);\n}\nfunction shapeToSet(s) {\n    const r = [];\n    for (let i = 0; i < s.m; i++) {\n        for (let j = 0; j < s.n; j++) {\n            if (s.data[i][j] > 0)\n                r.push([i, j]);\n        }\n    }\n    return r;\n}\nfunction getBounds(r) {\n    let [minX, minY, maxX, maxY] = [-1, -1, -1, -1];\n    for (const [x, y] of r) {\n        if (minX === -1 || minX > x)\n            minX = x;\n        if (maxX === -1 || maxX < x)\n            maxX = x;\n        if (minY === -1 || minY > y)\n            minY = y;\n        if (maxY === -1 || maxY < y)\n            maxY = y;\n    }\n    return [minX, minY, maxX, maxY];\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/shape.ts?");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appendButton\": () => (/* binding */ appendButton),\n/* harmony export */   \"createModel\": () => (/* binding */ createModel)\n/* harmony export */ });\n/// UI utils\nfunction appendButton(e, text, handler) {\n    const btn = document.createElement('button');\n    btn.textContent = text;\n    btn.onclick = handler;\n    e.appendChild(btn);\n    return btn;\n}\nfunction createModel() {\n    const layer = document.createElement('div');\n    layer.style.position = 'fixed';\n    layer.style.zIndex = '1';\n    layer.style.left = '0';\n    layer.style.top = '0';\n    layer.style.width = '100%';\n    layer.style.height = '100%';\n    layer.style.overflow = 'auto';\n    layer.style.backgroundColor = 'rgba(0,0,0,0.4)';\n    const content = document.createElement('div');\n    content.style.backgroundColor = '#fefefe';\n    content.style.marginLeft = 'auto';\n    content.style.marginRight = 'auto';\n    content.style.marginTop = '50px';\n    content.style.border = '1px solid #888';\n    content.style.display = 'table';\n    layer.appendChild(content);\n    return { layer, content };\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/ui.ts?");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"array2d\": () => (/* binding */ array2d),\n/* harmony export */   \"array3d\": () => (/* binding */ array3d),\n/* harmony export */   \"incCounter\": () => (/* binding */ incCounter),\n/* harmony export */   \"ndarray\": () => (/* binding */ ndarray),\n/* harmony export */   \"nextPermutation\": () => (/* binding */ nextPermutation),\n/* harmony export */   \"randomPickOne\": () => (/* binding */ randomPickOne),\n/* harmony export */   \"randomSubset\": () => (/* binding */ randomSubset),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"range2\": () => (/* binding */ range2),\n/* harmony export */   \"range2d\": () => (/* binding */ range2d),\n/* harmony export */   \"rangeND\": () => (/* binding */ rangeND),\n/* harmony export */   \"reverse\": () => (/* binding */ reverse),\n/* harmony export */   \"shuffle\": () => (/* binding */ shuffle),\n/* harmony export */   \"simplifyPathInPlace\": () => (/* binding */ simplifyPathInPlace),\n/* harmony export */   \"unique\": () => (/* binding */ unique)\n/* harmony export */ });\nfunction ndarray(dimensions, initVal) {\n    const createArray = function (dimensions, index, initVal) {\n        const d = dimensions[index];\n        const arr = new Array(d);\n        if (index < dimensions.length - 1) {\n            for (let i = 0; i < d; i++) {\n                arr[i] = createArray(dimensions, index + 1, initVal);\n            }\n        }\n        else {\n            arr.fill(initVal);\n        }\n        return arr;\n    };\n    return createArray(dimensions, 0, initVal);\n}\nfunction array2d(dimensions, initVal) {\n    return ndarray(dimensions, initVal);\n}\nfunction array3d(dimensions, initVal) {\n    return ndarray(dimensions, initVal);\n}\n/**\n * Shuffles array in place. ES6 version\n */\nfunction shuffle(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nfunction randomSubset(a, len) {\n    return shuffle([...a]).slice(0, len);\n}\nfunction* range(a, b) {\n    const step = a < b ? 1 : -1;\n    for (let i = a; i !== b; i += step) {\n        yield i;\n    }\n}\nfunction* range2d(a, b) {\n    yield* rangeND(a, b);\n}\n/// range(4) -> 0 1 2 3\n/// range(2,4) -> 2 3\n/// range([2,2]) -> [0,0], [0,1], [1,0], [1,1]\n/// range([1,1],[3,3]) -> [1,1], [1,2], [2,1], [2,2]\nfunction* rangeND(a, b) {\n    if (a.length !== b.length) {\n        throw Error('rangND: invalid argument');\n    }\n    const dim = a.length;\n    if (b === undefined)\n        [a, b] = [new Array(dim).fill(0), a];\n    const step = a.map((v, i) => v < b[i] ? 1 : -1);\n    // [1,2,3]->[5,6,7]\n    const v = [...a];\n    while (true) {\n        yield v;\n        let i = a.length - 1;\n        for (; i >= 0; i--) {\n            if (v[i] !== b[i] - step[i])\n                break;\n        }\n        if (i === -1)\n            break;\n        v[i] += step[i];\n        for (i++; i < a.length; i++) {\n            v[i] = a[i];\n        }\n    }\n}\nfunction* range2(a, b) {\n    for (let i = a; i !== b; i++) {\n        yield i;\n    }\n}\nfunction reverse(arr, i, j) {\n    for (let a = i, b = j; a < b; a++, b--) {\n        [arr[a], arr[b]] = [arr[b], arr[a]];\n    }\n}\nfunction nextPermutation(arr, less = (a, b) => a < b) {\n    for (let i = arr.length - 2; i >= 0; i--) {\n        // find rightmost element that is smaller than successor\n        if (less(arr[i], arr[i + 1])) {\n            let k = arr.length;\n            do {\n                k--;\n            } while (!less(arr[i], arr[k]));\n            [arr[i], arr[k]] = [arr[k], arr[i]];\n            reverse(arr, i + 1, arr.length - 1);\n            return true;\n        }\n    }\n    reverse(arr, 0, arr.length - 1);\n    return false;\n}\nfunction incCounter(obj, property) {\n    if (property in obj) {\n        obj[property]++;\n    }\n    else {\n        obj[property] = 1;\n    }\n}\nfunction randomPickOne(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n/**\n * filter unique values in a sorted array\n */\nfunction unique(arr, compareFunc) {\n    if (arr.length === 0)\n        return [];\n    let lastValue = arr[0];\n    const ret = [lastValue];\n    for (let i = 1; i < arr.length; i++) {\n        if (compareFunc(lastValue, arr[i]) !== 0) {\n            ret.push(arr[i]);\n            lastValue = arr[i];\n        }\n    }\n    return ret;\n}\n// if 3 points in a line, remove the middle one\nfunction simplifyPathInPlace(p) {\n    if (p.length < 3)\n        return;\n    let i = 0;\n    while (i < p.length - 2) {\n        const [x1, y1] = p[i];\n        const [x2, y2] = p[i + 1];\n        const [x3, y3] = p[i + 2];\n        if ((x1 - x2) * (y2 - y3) === (y1 - y2) * (x2 - x3)) {\n            p.splice(i + 1, 1);\n        }\n        else {\n            i++;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://witness-puzzle/./src/util.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.ts");
/******/ 	
/******/ })()
;